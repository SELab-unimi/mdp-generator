/*
 * generated by Xtext 2.13.0
 */
package it.unimi.di.se.mdp.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import it.unimi.di.se.mdp.mdpDsl.MDPModel
import java.util.HashMap
import it.unimi.di.se.mdp.mdpDsl.State
import it.unimi.di.se.mdp.mdpDsl.Arc
import it.unimi.di.se.mdp.mdpDsl.ObservableMap
import it.unimi.di.se.mdp.mdpDsl.ControllableMap

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MdpDslGenerator extends AbstractGenerator {
	
	public final static String OBSERVABLE = 'observable'
	public final static String CONTROLLABLE = 'controllable'
	
	var observableMethods = new HashMap<String, MonitorObserveCompiler>()
	var controllableActions = new HashMap<String, MonitorControlCompiler>

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var model = resource.allContents.toIterable.filter(typeof(MDPModel)).findFirst[it !== null]
		//fsa.generateFile("prism/" + model.name + ".sm", resource.compilePrismModel)
		var stateMap = createStateMapping(resource.allContents.toIterable.filter(typeof(State)))
		fsa.generateFile("jmarkov/" + model.name + ".jmdp", resource.compileJMarkovInputFile(stateMap))
		resetData
		parseObserveMappings(resource.allContents.toIterable.filter(typeof(ObservableMap)))
		parseControlMappings(resource.allContents.toIterable.filter(typeof(ControllableMap)))
		fsa.generateFile("it/unimi/di/se/monitor/EventHandler.aj", resource.compileEventHandler)	
	}
	
	
	def HashMap<String, Integer> createStateMapping(Iterable<State> states) {
		var result = new HashMap<String, Integer>()
		var i = 1
		for(State s: states)
			result.put(s.name, i++)
		return result
	}
	
	def compileJMarkovInputFile(Resource resource, HashMap<String, Integer> stateMap) '''
		«FOR state: resource.allContents.toIterable.filter(typeof(State))» «state.name»«IF state.initial» i«ENDIF»«IF state.prior.size > 0» u«ENDIF»,«ENDFOR»
		«FOR arc: resource.allContents.toIterable.filter(typeof(Arc))»
			«arc.src.name» «arc.act.name» «arc.dst.name» «arc.probability»
		«ENDFOR»
	'''
	
	def compileEventHandler(Resource resource) '''
		package it.unimi.di.se.monitor;
		
		import org.slf4j.Logger;
		import org.slf4j.LoggerFactory;
		
		import org.aspectj.lang.annotation.After;
		import org.aspectj.lang.annotation.AfterReturning;
		import org.aspectj.lang.annotation.Aspect;
		import org.aspectj.lang.annotation.Before;
		import org.aspectj.lang.annotation.Pointcut;
		
		
		@Aspect
		public class EventHandler {
		    
		    private Monitor monitor = null;
		    private static final Logger log = LoggerFactory.getLogger(EventHandler.class.getName());
		    static final String MODEL_PATH = "src/main/resources/«resource.URI.lastSegment»";
		    
		    @Pointcut("execution(public static void main(..))")
		    void mainMethod() {}
		    
		    @Before(value="mainMethod()")
		    public void initMonitor(){
		    		log.info("Monitor initialization...");
		    		monitor = new Monitor();
		    		monitor.launch();
			}
		        
		    @After(value="mainMethod()")
		    public void shutdownMonitor(){
		    		log.info("Shutting down Monitor...");
		    		monitor.addEvent(Event.StopEvent());
			}
			«FOR signature: observableMethods.keySet»
				«observableMethods.get(signature).compileAdvices(signature)»
			«ENDFOR»
		}
	'''
	
	def parseObserveMappings(Iterable<ObservableMap> maps) {
		for(ObservableMap m: maps)
			m.parseObserveMapping
	}
	
	def parseObserveMapping(ObservableMap map) {
		var MonitorObserveCompiler compiler
		if(observableMethods.containsKey(map.signature))
			compiler = observableMethods.get(map.signature)
		else {
			compiler = new MonitorObserveCompiler
			observableMethods.put(map.signature, compiler)
		}
		compiler.parse(map)
	}
	
	def parseControlMappings(Iterable<ControllableMap> maps) {
		for(ControllableMap m: maps)
			m.parseControlMapping
	}
	
	def parseControlMapping(ControllableMap map) {
		var MonitorControlCompiler compiler
		if(controllableActions.containsKey(map.signature))
			compiler = controllableActions.get(map.signature)
		else {
			compiler = new MonitorControlCompiler
			controllableActions.put(map.signature, compiler)
		}
		
		// TODO compiler.parse(map)
	}
	
	def resetData() {
		observableMethods.clear
		controllableActions.clear
	}
	
}
